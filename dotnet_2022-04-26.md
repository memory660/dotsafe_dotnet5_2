# docker

```
docker system prune -a
docker 
```

# dotnet

installer le SDK de .net

```
dotnet --version
dotnet --list-sdks

visual studio -> api asp.NET

dotnet new console --output myApp2
dotnet run --project myApp2

// launchSettings.json -> avec le profile par défaut: "Com.Core.Dotsafe.UI"
dotnet run   

dotnet run  --launch-profil "IIS Express"
dotnet run  --environment staging
```

# outils

```odata``` : cadrer l'ensemble du REST au lieu de faire du web api rest full

# tests

- ajouter un nouveau projet


- solution le projet principal: webApplicationApi -> ajouter ->  nouveau projet
- type de projet -> test
- -> projet de test xUnit

- sur le nouveau projet test -> ajouter -> reference de projet -> [webapplicationApi1]

# structure

```
projet principal API        ./          api qui utilisent Domain, Infrastructure...

projet Domain               /libs       les entités
projet Infrastructure       /libs       les repositories
projet test                 /test       les tests
```

# domain

- creer dossiers Libs -> ajouter un nouveau projet -> bibliotheque -> dotnet core ->  [SelfieAWookies.Core.Selfies.Domain]
- y mettre les "entités"

- sur le projet principal -> ajouter reference -> ...du domain....

- projet: SelfieAWookies.Core.Selfies.Domain

Selfie.cs

```c#
    public class Selfie
    {
        #region Properties
        public int Id { get; set; }

        public string Title { get; set; }

        public string ImagePath { get; set; }

        public Wookie Wookie { get; set; }
        #endregion
    }
```

Wookie.cs

```c#
    public class Wookie
    {
        #region Properties
        public int Id { get; set; }

        public List<Selfie> Selfies { get; set; }
        #endregion
    }
```

# ORM - INFRASTRUCTURE

- linQ: 
    - n'est pas connecté à la base de données
    - moteur de requetage de collection en memoire
- EF Core  : Entity Framework

- sur Libs -> ajouter un nouveau projet -> bibliotheque -> dotnet core ->  [selfie.Core.Selfies.Infrastructure]
- sur le projet principal -> ajouter reference -> ...Infrastructure....

-> selfie.Core.Selfies.Infrastructure -> dependancies -> creer dossier: Data -> ajouter class: [Selfiescontext]

```c#
public class SelfieContext: DbContext {
```

DbContext -> installer et rechercher -> installer avec le gestionnaire -> parcourir -> version .... 

- ```orm``` represente les objets/les collections sur lesquels on veut travailler
- chaque collection sera representée par un ```DBSet``` represente les entités que l'on veut surveiller leur etats s'il faut mettre à jour



## projet: SelfieAWookies.Core.Selfies.Infrastructures

Data/SelfiesContext.cs

```c#
public class SelfieContext: DbContext {

    // pour ajouter des confuigurations et des fonctionnalités
    // tables reliés aux classes, les liens rerlationnels...
    protected override void OnModelCreating(ModelBuilder modelBuilder) {
        base.OnModelCreating(modelBuilder);

        // configuration personnalisé de l'entité Selfie avec la base de données
        modelBuilder.ApplyConfiguration(new SelfieEntityTypeConfiguration());  
        // configuration personnalisé de l'entité Wookie avec la base de données    
        modelBuilder.ApplyConfiguration(new WookieEntityTypeConfiguration());    
    }

    public DBset<Selfie> Selfies { get; set; }
    public DBset<Wookie> Wookies { get; set; }
```


Data/TypeConfigurations/SelfieEntityTypeConfiguration.cs

```c#    
    class SelfieEntityTypeConfiguration : IEntityTypeConfiguration<Selfie>
    {
        #region Public methods
        public void Configure(EntityTypeBuilder<Selfie> builder)
        {
            builder.ToTable("Selfie");

            builder.HasKey(item => item.Id);
            builder.HasOne(item => item.Wookie)     // Selfie -> public Wookie Wookie { get; set; }
                   .WithMany(item => item.Selfies); // Wookie -> public List<Selfie> Selfies { get; set; }
        }
        #endregion
    }
```

- shadow key : fait la correspondance automatique entre wookie et wookieId


Data/TypeConfigurations/WookieEntityTypeConfiguration.cs

```c#
    class WookieEntityTypeConfiguration : IEntityTypeConfiguration<Wookie>
    {
        #region Public methods
        public void Configure(EntityTypeBuilder<Wookie> builder)
        {
            builder.ToTable("Wookie");
        }
        #endregion
    }
```

## autres versions

Selfie.cs

```c#
    public class Selfie
    {
        #region Properties
        public int Id { get; set; }

        public string Title { get; set; }

        public string ImagePath { get; set; }

        public int WookieId { get; set; }  // ajoute WookieId
        public Wookie Wookie { get; set; }
        #endregion
    }
```

Data/TypeConfigurations/SelfieEntityTypeConfiguration.cs

```c#    
    class SelfieEntityTypeConfiguration : IEntityTypeConfiguration<Selfie>
    {
        #region Public methods
        public void Configure(EntityTypeBuilder<Selfie> builder)
        {
            builder.ToTable("Selfie");

            builder.HasKey(item => item.Id);

            // les liens se font automatiquement grace à la navigation properties
            // Selfie -> public int WookieId { get; set; }
            // Wookie -> public List<Selfie> Selfies { get; set; }
        }
        #endregion
    }
```

SelfiesController

```c#   
        [HttpGet]
        public IActionResult TestAMoi()
        {
            // Include:  prend en compte une relation
            var model = this._context.Selfies.Include(item => item.Wookie).ToList();
            
            return this.Ok(model);
        }
```

- resultats:
    - probleme de cycle infini, le selfie accede au wookie qui accede au selfie etc...
- solutions :
    - solution (1)

wookie.cs

```c# 
[jsonIgnore]
   public List<Selfie> Selfies { get; set; }
```   

    - solution (2) ajouter .select

SelfiesController

```c#   
        [HttpGet]
        public IActionResult TestAMoi()
        {
            // Include:  prend en compte une relation
            var model = this._context.Selfies.Include(item => item.Wookie).Select(item => new { Title = item.Title, WookieId = item.Wookie.Id, NbSelfiesFromWookie = item.Wookie.Selfies.Count }).ToList();
            
            return this.Ok(model);
        }
```


# repository

- 1. créer une interface

domain/ISelfieRepository.cs

```c#   
    public interface ISelfieRepository : IRepository
    {
        ICollection<Selfie> GetAll();
    }
```

infrastructure/Repositories/DefaultSelfieRepository.cs

```c# 
    public class DefaultSelfieRepository : ISelfieRepository
    {
        #region Fields
        private readonly SelfiesContext _context = null;
        #endregion

        #region Constructors
        public DefaultSelfieRepository(SelfiesContext context)
        {
            this._context = context;
        }
        #endregion

        #region Public methods
        public ICollection<Selfie> GetAll()
        {
            return this._context.Selfies.Include(item => item.Wookie).ToList();
        }
        #endregion

        #region Properties
        public IUnitOfWork UnitOfWork => this._context;
        #endregion
    }
```


- declarer le service pour qu'il soit pris en compte dans l'injection de dépendance

Startup.cs

```c# 
// s'il trouve: ISelfieRepository alors instancie DefaultSelfieRepository pour l'injection
services.AddTranscient<ISelfieRepository, DefaultSelfieRepository>();
```

SelfieAWookie.API.UI.Controllers

```c# 
    [Route("api/v1/[controller]")]
    [ApiController]
    public class SelfiesController : ControllerBase
    {
        private readonly ISelfieRepository _repository = null;

        public SelfiesController(ISelfieRepository repository)
        {
            this._repository = repository;
        }
        ...
        ...
        [HttpGet]
        public IActionResult TestAMoi()
        {
            var selfiesList = this._repository.GetAll();
            var model = selfiesList.Select(item => new SelfieResumeDto() { Title = item.Title, WookieId = item.Wookie.Id, NbSelfiesFromWookie = (item.Wookie?.Selfies?.Count).GetValueOrDefault(0) }).ToList();
            
            return this.Ok(model);
        }        
```

# transcient, scope, singleton : durée de vie d'un objet

```c# 
services.AddScoped<ISelfieRepository, DefaultSelfieRepository>();           // tant que requete existe (à préférer)
services.AddTranscient<ISelfieRepository, DefaultSelfieRepository>();       // fait un new a chaque fois

services.AddSingleton(typeof(DefaultSelfieRepository));
services.AddSingleton<DefaultSelfieRepository>();
```

# méthode d'extension

- méthode qui vient s'accrocher à un objet sans faire partie de la classe de base

UI...../ExtensionMethods/DIMethods.cs

```c# 
    public static class DIMethods
    {
        #region Public methods
        /// <summary>
        /// Prepare customs dependency injections
        /// </summary>
        /// <param name="services"></param>
        public static void AddInjections(this IServiceCollection services)
        {
            services.AddScoped<ISelfieRepository, DefaultSelfieRepository>();
        }
        #endregion
    }
```

Startup.cs

```c# 
// au lieu de: 
// services.AddTranscient<ISelfieRepository, DefaultSelfieRepository>();
services.AddInjections();
```

# Unit Of Work

```
controller  --------------------------------------------------> DBContext -----------------> Entity framework et database

controller  ---> Unit Of Work (repository1(--> DBContext), repository2(--> ?????), ...) ---> Entity framework et database                                       
```

```ts
controller
    repository->getAll()
infrastructure
    SelfiesContext.cs
        public class SelfiesContext : DbContext, IUnitOfWork    // (1)
    DefaultSelfieRepository : ISelfieRepository
        GetAll() {.......}
        public IUnitOfWork UnitOfWork => this._context;         // (2)
    SelfiesAWookies.Core.Framework        
        public interface IRepository { IUnitOfWork UnitOfWork { get; } }
        public interface IUnitOfWork { int SaveChanges(); }
```

-(1) IUnitOfWork contient SaveChanges() qui est en fait defini dans : DbContext.SaveChanges()
-(2) le context peut etre n'importe quoi, un enregistrement dans une base de donnée, dans un fichier....


- ameliorer l'architecture
- découpler la partie acces et enregistrement de la base de donnéé ou partie controleur et dbContext
- enregistrement est lié à la base de donnée

- agregat est un ensemble d'enregistrement à faire absolu en meme temps
- exemple : enregistrement d'une commande avec ses items, (l'(ensemble est un agregat))
- IUnitOfWork: unité de travail sur l'agregat
- le repository va charger un IUnitOfWork sans se soucier que celui ci fait reference à selfieDbContext (il peut très bien faire reference à autre chose)

- nouveau projet: SelfiesAWookies.Core.Framework

IUnitOfWork.cs

```c# 
    public interface IUnitOfWork
    {
        int SaveChanges();
    }
```

SelfieAWookies.Core.Selfies.Infrastructures

SelfiesContext.cs

```c# 
    public class SelfiesContext : DbContext, IUnitOfWork    // ajout IUnitOfWork
    {                                                       // à savoir que SaveChanges existe dans DbContext
```


section 6 - 53

IRepository.cs

```c# 
    public interface IRepository
    {
        IUnitOfWork UnitOfWork { get; }
    }
```

Repositories/DefaultSelfieRepository.cs

```c# 
    public class DefaultSelfieRepository : ISelfieRepository
    {
```


# migration

- creer un projet dédié pour la migration: ```SelfieAWookies.Core.Selfies.Data.Migrations```
- ajouter la dependance à ```infrastructure```
- installer la dépendance ```microsoftEntityframeworkDesign``` ```ef relationnal``` ```ef relationnal Design``` dans le projet migration:
    - /migration/dependance -> gerer les packages nuGet... -> parcourir -> [microsoftEntityframeworkDesign] -> installer
    - /migration -> regenerer   (recompiler)
- installer dependance de notre base de donnée cad sqlServer
    - /migration/dependance -> gerer les packages nuGet... -> parcourir -> [sqlserver] -> installer
    - /migration -> regenerer   (recompiler)

```
// liste de toutes les commandes LCI
dotnet -h
// ajouter d'autres outils
dotnet tool
// liste des outils installés en plus
dotnet tool list

// dotnet-ef contient ce qu'il faut pour effectuer des migrations
dotnet tool install --global dotnet-ef 

dotnet ef migrations list

// se metre dans le dossier Infrastructure
cd \libs\Com.Core.Dotsafe.Infrastructure
// avoir un projet de migration par context
dotnet ef migrations add initDatabase --project=../Com.Core.Dotsafe.Data.Migrations

// appliquer
dotnet ef database update
```

- ex: on ajoute un colonne description

```
dotnet ef migrations add addDescription --startup-project . --project=../SelfiesAWookies.Core.Selfies.Data.migrations
dotnet ef database update --project ../SelfiesAWookies.Core.Selfies.Data.migrations --startup-project .
```

- indiquer le context pour que la migration fonctionne :
- /infrastructure/data -> ajouter class:

SelfieContextFactory

```c#
    public class SelfiesContextFactory : IDesignTimeDbContextFactory<SelfiesContext>
    {
        #region Public methods
        public SelfiesContext CreateDbContext(string[] args)
        {
            ConfigurationBuilder configurationbuilder = new ConfigurationBuilder();  // microsoft extension configuration
 
            configurationbuilder.AddJsonFile(Path.Combine(Directory.GetCurrentDirectory(), "Settings", "appSettings.json"));

            IConfigurationRoot configurationRoot = configurationbuilder.Build();

            DbContextOptionsBuilder builder = new DbContextOptionsBuilder();
            builder.UseSqlServer(configurationRoot.GetConnectionString("SelfiesDatabase"), b => b.MigrationsAssembly("SelfieAWookies.Core.Selfies.Data.Migrations"));

            SelfiesContext context = new SelfiesContext(builder.Options);

            return context;
        }
        #endregion
    }
```

- /infrastructure/dependance -> gerer les packages nuGet... -> parcourir -> [microsoft extension configuration] -> installer
- /infrastructure/dependance -> gerer les packages nuGet... -> parcourir -> [microsoft extension configuration json] -> installer

- créer : /infrastructure/Settings

/infrastructure/Settings/appSettings.json

```json
{
  "ConnectionStrings": {
    "SelfiesDatabase": "Server=DESKTOP-ETKR0OM\\SQLEXPRESS;Database=SelfiesAWookies.Database.dev;Trusted_Connection=True;"
  }
}
```

# CORS

- on peut configurer les CORS sur IIS
- sinon, si on n'utilise pas IIS, on configure comme ci dessous:
    
- créer un classe: 
- à savoir: on peut affiner en fonction des besoins differents CORS et les appliquer ou l'ont veut dans le controlleur

/ExtensionMethods/SecurityMethods.cs

```c#
    /// </summary>
    public static class SecurityMethods
    {
        #region Constants
        public const string DEFAULT_POLICY = "DEFAULT_POLICY";
        public const string DEFAULT_POLICY_2 = "DEFAULT_POLICY_2";
        public const string DEFAULT_POLICY_3 = "DEFAULT_POLICY_3";
        #endregion

        #region Public methods
        /// <summary>
        /// Add cors and jwt configuration
        /// </summary>
        /// <param name="services"></param>
        public static void AddCustomSecurity(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddCors(options =>
            {
                options.AddPolicy(DEFAULT_POLICY, builder =>
                {
                    builder.WithOrigins(configuration["Cors:Origin"])   // appsettings.json
                           .AllowAnyHeader()
                           .AllowAnyMethod();
                });

                options.AddPolicy(DEFAULT_POLICY_2, builder =>
                {
                    builder.WithOrigins("http://127.0.0.1:5501")
                           .AllowAnyHeader()
                           .AllowAnyMethod();
                });

                options.AddPolicy(DEFAULT_POLICY_3, builder =>
                {
                    builder.WithOrigins("http://127.0.0.1:5502")
                           .AllowAnyHeader()
                           .AllowAnyMethod();
                });
            });
        }
        #endregion
    }
```

startup.cs

```c#
        ...
        public void ConfigureServices(IServiceCollection services)
        {
            ...
            services.AddCustomSecurity();

        ...
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            ...
            app.UseCors(SecurityMethods.DEFAULT_POLICY_2);            
```

- 

appSettings.json

```json
...
  "Cors": {
    "Origin": "http://127.0.0.1:5500"
  },
```



- appliquer un CORS à un controller:

```c#
...
    [Route("api/v1/[controller]")]
    [ApiController]
    [EnableCors(SecurityMethods.DEFAULT_POLICY_3)]
    public class SelfiesController : ControllerBase
    {
        ...
```

- appliquer un CORS à une méthode du controlleur:

```c#
...
        [HttpGet]
        [EnableCors(SecurityMethods.DEFAULT_POLICY_3)]
        public IActionResult GetAll([FromQuery] int wookieId = 0)
        {          
```            

```c#
...
        [HttpGet]
        [DisableCors()]      // bloquer les CORS
        public IActionResult GetAll([FromQuery] int wookieId = 0)
        {            
```  

# JWT

- il faut créer un nouveau context
- nous travaillons sur le context: SelfiesContext
- on peut creer un nouveau context: authenticationContext ou l'ajouter à : SelfiesContext
- pour la simplicité, on l'ajoute à : SelfiesContext

infrastructure/data/SelfiesContext.cs

```c#
    // IdentityDbContext au lieu de: DbContext
    public class SelfiesContext : IdentityDbContext, IUnitOfWork
    {
```        

- creer une nouvelle migration pour prendre en compte les nouvelles tables d'utlisateurs, de roles... (inclus dans IdentityDbContext)

```  
dotnet ef migrations add addIdentity --project=../SelfiesAWookies.Core.Selfies.Data.migrations
dotnet ef database update
```  

attention: pensez à builder (regenerer) migrations

- configuration


- /dependance -> gerer les packages nuGet... -> parcourir -> [microsoft aspnetcore authentication jwtBearer] -> installer
- /dependance -> gerer les packages nuGet... -> parcourir -> [microsoft aspnetcore identity ui] -> installer

startup.cs

```c#
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddDbContext<SelfiesContext>(options =>
            {
                options.UseSqlServer(this.Configuration.GetConnectionString("SelfiesDatabase"), sqlOptions => {});
            });
            services.AddDefaultIdentity<IdentityUser>(options =>
            {
                // options.SignIn.RequireConfirmedEmail = true;
            }).AddEntityFrameworkStores<SelfiesContext>();

            services.AddInjections();
            services.AddCustomSecurity(this.Configuration);
            ...
            ...
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            ...

            app.UseAuthentication();
            app.UseAuthorization();            
```


appSettings.json

```json
"jwt": {
    "key": "mon secret phrase"
}
```


/ExtensionMethods/SecurityMethods.cs

```c#
    public static class SecurityMethods
    {
        #region Constants
        public const string DEFAULT_POLICY = "DEFAULT_POLICY";
        public const string DEFAULT_POLICY_2 = "DEFAULT_POLICY_2";
        public const string DEFAULT_POLICY_3 = "DEFAULT_POLICY_3";
        #endregion

        #region Public methods
        /// <summary>
        /// Add cors and jwt configuration
        /// </summary>
        /// <param name="services"></param>
        public static void AddCustomSecurity(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddCustomCors(configuration);
            services.AddCustomAuthentication(configuration);
        }

        public static void AddCustomAuthentication(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddJwtBearer(options =>
            {
                string maClef = configuration["Jwt:Key"];   // secret phrase
                options.SaveToken = true;
                options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters()
                {
                    IssuerSigningKey = new SymmetricSecurityKey(System.Text.Encoding.UTF8.GetBytes(maClef)),
                    ValidateAudience = false,
                    ValidateIssuer = false,
                    ValidateActor = false,
                    ValidateLifetime = true
                };
            }); ;
        }

        public static void AddCustomCors(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddCors(options =>
            {
                options.AddPolicy(DEFAULT_POLICY, builder =>
                {
                    builder.WithOrigins(configuration["Cors:Origin"])
                           .AllowAnyHeader()
                           .AllowAnyMethod();
                });

                options.AddPolicy(DEFAULT_POLICY_2, builder =>
                {
                    builder.WithOrigins("http://127.0.0.1:5501")
                           .AllowAnyHeader()
                           .AllowAnyMethod();
                });

                options.AddPolicy(DEFAULT_POLICY_3, builder =>
                {
                    builder.WithOrigins("http://127.0.0.1:5502")
                           .AllowAnyHeader()
                           .AllowAnyMethod();
                });
            });
        }
        #endregion
    }
```

- public class AuthenticationProperties
    - Dictionnaire utilisé pour stocker les valeurs d'état relatives à la session d'authentification
- options.SaveToken = true;
    - Définit si le jeton du porteur doit être stocké dans le AuthenticationProperties après une autorisation réussie.
- ValidateAudience = false,
    - Détermine si les audiences trouvées dans un JwtSecurityToken sont valides.
- ValidateIssuer = false,
    - Obtient ou définit un booléen pour contrôler si l'émetteur sera validé pendant la validation du jeton.
- ValidateActor = false,
    - Obtient ou définit une valeur indiquant si un jeton d'acteur est détecté, s'il doit être validé. La valeur par défaut est false.
- ValidateLifetime = true
    - Obtient ou définit un booléen pour contrôler si la durée de vie sera validée pendant la validation du jeton.



- creer : AuthenticateController.cs

```c#
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;
using SelfieAWookie.API.UI.Application.DTOs;
using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Security.Claims;
using System.Text;
using System.Threading.Tasks;

namespace SelfieAWookie.API.UI.Controllers
{
    [Route("api/v1/[controller]")]
    [ApiController]
    public class AuthenticateController : ControllerBase
    {
        #region Fields
        private UserManager<IdentityUser> _userManager = null;
        private IConfiguration _configuration = null;
        #endregion

        #region Constructors
        public AuthenticateController(UserManager<IdentityUser> userManager, IConfiguration configuration)
        {
            this._userManager = userManager;
            this._configuration = configuration;
        }
        #endregion

        #region Public methods
        [HttpPost]
        [Route("register")]
        public async Task<IActionResult> Register([FromBody] AuthenticateUserDto dtoUser)
        {
            IActionResult result = this.BadRequest();

            var user = new IdentityUser(dtoUser.Login);
            user.Email = dtoUser.Login;
            user.UserName = dtoUser.Name;
            var success = await this._userManager.CreateAsync(user, dtoUser.Password);

            if (success.Succeeded)
            {
                dtoUser.Token = this.GenerateJwtToken(user);
                result = this.Ok(dtoUser);
            }

            return result;
        }

        [HttpPost]
        public async Task<IActionResult> Login([FromBody] AuthenticateUserDto dtoUser)
        {
            IActionResult result = this.BadRequest();

            var user = await this._userManager.FindByEmailAsync(dtoUser.Login);
            if (user != null)
            {
                var verif = await this._userManager.CheckPasswordAsync(user, dtoUser.Password);
                if (verif)
                {

                    result = this.Ok(new AuthenticateUserDto()
                    {
                        Login = user.Email,
                        Name = user.UserName,
                        Token = this.GenerateJwtToken(user)
                    });
                }
            }

            return result;
        }
        #endregion

        #region Internal methods
        private string GenerateJwtToken(IdentityUser user)
        {
            // Now its ime to define the jwt token which will be responsible of creating our tokens
            var jwtTokenHandler = new JwtSecurityTokenHandler();

            // We get our secret from the appsettings
            var key = Encoding.UTF8.GetBytes(this._configuration["Jwt:Key"]);

            // we define our token descriptor
            // We need to utilise claims which are properties in our token which gives information about the token
            // which belong to the specific user who it belongs to
            // so it could contain their id, name, email the good part is that these information
            // are generated by our server and identity framework which is valid and trusted
            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(new[]
                {
                new Claim("Id", user.Id),
                new Claim(JwtRegisteredClaimNames.Sub, user.Email),
                new Claim(JwtRegisteredClaimNames.Email, user.Email),
                // the JTI is used for our refresh token which we will be convering in the next video
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
            }),
                // the life span of the token needs to be shorter and utilise refresh token to keep the user signedin
                // but since this is a demo app we can extend it to fit our current need
                Expires = DateTime.UtcNow.AddHours(6),
                // here we are adding the encryption alogorithim information which will be used to decrypt our token
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha512Signature)
            };

            var token = jwtTokenHandler.CreateToken(tokenDescriptor);

            var jwtToken = jwtTokenHandler.WriteToken(token);

            return jwtToken;
        }
        #endregion
    }
}
```

controller

```c#
    [ApiController]
    [Route("api/v1/[controller]")]
    [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]         // 
    [EnableCors(SecurityMethods.DEFAULT_POLICY_3)]
    public class SelfiesController : ControllerBase
    {
```        



- usersecret
- ne pas enregistrer les données sensibles dans : appSettings.json
- projet -> gerer les données secretes de l'utilisateur -> 

secrets.json

```json
{
    "jwt": {
        "key": "mon secret phrase"
    }
}
```
  
- voir si on est en developpement ?

/properties/launchSettings.json

```json
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
```

donc on est bien en developpement !

- pour la prod, mettre dans une variable d'environement !


# codes


## controller 1

- ici, on utilise le context directement dans le controller et on effectue une requete en base. ce n'est pas une bonne pratique.
- il faut créer un repository ou on utilise le context et effectue la requete en base

```c#
namespace Com.Core.Dotsafe.UI.Controllers
{
    [Route("api/v1/[controller]")]
    [ApiController]
    public class DotsafesController : ControllerBase
    {
        #region Fields
        private readonly DotsafesContext _context = null;       // LE CONTEXT
        #endregion

        #region Constructors
        public DotsafesController(DotsafesContext context)      // LE CONTEXT
        {
            this._context = context;
        }
        #endregion

        #region Public methods

        [HttpGet]
        public IActionResult TestAMoi()
        {
            // 1
            var model = Enumerable.Range(1, 10).Select(item => new User() { Id = item });
            return this.StatusCode(StatusCodes.Status204NoContent);

            // 2
            var model = this._context.Users.ToList();
            return this.Ok(model);

            // 3
            var query = from contribution in this._context.Users select contribution;
            return this.Ok(query.ToList());

            // 4
            var query = from contribution in this._context.Contributions
                        join user in this._context.Users on contribution.User.Id equals user.Id
                        select user;
            return this.Ok(query.ToList());
            
            // 5
            var model = this._context.Contributions
                .Include(item => item.User)
                .Select(item => new {name = item.name, user = item.User.username, nbcontributions = item.User.Contributions.Count});   // sans dto
            return this.Ok(model.ToList());

        }
        #endregion
    }
}
```

## controller 2

- ne pas oublier de déclarer IContributionRepository dans: startup.cs pour qu'il soit reconnu comme injectable

```c#
namespace Com.Core.Dotsafe.UI.Controllers
{
    [Route("api/v1/[controller]")]
    [ApiController]
    public class DotsafesController : ControllerBase
    {
        #region Fields
        private readonly IContributionRepository _repository = null;
        #endregion

        #region Constructors
        public DotsafesController(IContributionRepository repository)   // déclaré dans: startup.cs
        {
            this._repository = repository;
        }
        #endregion

        #region Public methods

        [HttpGet]
        public IActionResult TestAMoi()
        {
            var contributions = this._repository.GetAll();
            return Ok(contributions);
        }
        #endregion
    }
}
```

startup.cs
```c#
        public void ConfigureServices(IServiceCollection services)
        {
            ...
            // déclarer pour l'injection de dépendance
            // il faut lier l'interface: IContributionRepository à la classe: DefaultContributionRepository
            services.AddTransient<IContributionRepository, DefaultContributionRepository>();
```            

domain...../IContributionRepository.cs

```c#
namespace Com.Core.Dotsafe.Domain
{
    public  interface IContributionRepository
    {
        ICollection<Contribution> GetAll();
    }
}
```


Infrastructure...../Repositories/DefaultContributionRepository.cs

```c#
namespace Com.Core.Dotsafe.Infrastructure.Repositories

{
    public class DefaultContributionRepository : IContributionRepository
    {
        private readonly DotsafesContext _context = null;
        public DefaultContributionRepository(DotsafesContext context)
        {
            this._context = context;
        }

        public ICollection<Contribution> GetAll()
        {
            return this._context.Contributions.ToList();
        }
    }
}
```

## dto

## default binding

```c#
namespace Com.Core.Dotsafe.UI.Dtos
{
    public class ContributionDto
    {
        public string name { get; set; }
        public string test { get; set; }
    }
```

```c#
        [HttpPost]
        public IActionResult save(ContributionDto contribution)
        {

            return Ok(contribution);
        }
```    

- instancie l'objet: ContributionDto
- prend tous les parametres du body de la requete et essaye de faire correspondre avec l'objet: ContributionDto
- comme test ne correspond a aucune propriétés de : ContributionDto alors sa valeur = null  (test=null)

```c#
namespace Com.Core.Dotsafe.Infrastructure.Repositories
{
    public class DefaultContributionRepository : IContributionRepository
    {
...

        public Contribution AddOne(Contribution contribution)
        {
            return this._context.Contributions.Add(contribution).Entity;
        }
...
```

```c#
        [HttpPost]
        public IActionResult save(ContributionDto contribution)
        {
            Contribution newContribution = this._repository.AddOne(new Contribution() { 
                name = contribution.name
            });

            this._repository.UnitOfWork.SaveChanges();

            if (newContribution != null)
            {
                return Ok(newContribution);
            }

            return Ok(BadRequest());
        }
```        

# query et rest

- [FromQuery] -Obtient des valeurs à partir de la chaîne de requête.
- [FromRoute] -Obtient des valeurs à partir des données d’itinéraire.
- [FromForm] -Obtient des valeurs à partir de champs de formulaire publiés.
- [FromBody] -Obtient les valeurs du corps de la demande.
- [FromHeader] -Obtient des valeurs à partir des en-têtes HTTP.


## exemple:

https://localhost:44364/api/v1/Dotsafes?userId=1

```c#
       [HttpGet]
        public IActionResult GetAll(int userId)
        {
```

## FromQuery (plus securisé, bonne pratique)

```c#
        [HttpGet]
        public IActionResult GetAll([FromQuery] int userId)
        {
```            

# securité - cors

Startup.cs

```c#
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
...
            app.UseCors();
```



/.......UI/ExtensionMethods/SecurityMethods.cs

```c#
namespace SelfieAWookie.API.UI.ExtensionMethods
{
    /// <summary>
    /// About security (cors, jwt)
    /// </summary>
    public static class SecurityMethods
    {
        #region Constants
        public const string DEFAULT_POLICY = "DEFAULT_POLICY";
        public const string DEFAULT_POLICY_2 = "DEFAULT_POLICY_2";
        public const string DEFAULT_POLICY_3 = "DEFAULT_POLICY_3";
        #endregion

        #region Public methods
        /// <summary>
        /// Add cors and jwt configuration
        /// </summary>
        /// <param name="services"></param>
        public static void AddCustomSecurity(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddCustomCors(configuration);
        }

        public static void AddCustomCors(this IServiceCollection services, IConfiguration configuration)
        {
            CorsOption corsOption = new CorsOption();
            configuration.GetSection("Cors").Bind(corsOption);

            services.AddCors(options =>
            {
                options.AddPolicy(DEFAULT_POLICY, builder =>
                {
                    builder.WithOrigins(corsOption.Origin)
                           .AllowAnyHeader()
                           .AllowAnyMethod();
                });

                options.AddPolicy(DEFAULT_POLICY_2, builder =>
                {
                    builder.WithOrigins("http://127.0.0.1:5501")
                           .AllowAnyHeader()
                           .AllowAnyMethod();
                });

                options.AddPolicy(DEFAULT_POLICY_3, builder =>
                {
                    builder.WithOrigins("http://127.0.0.1:5502")
                           .AllowAnyHeader()
                           .AllowAnyMethod();
                });
            });
        }
        #endregion
    }
}
```

## mettre cors au niveau global

Startup.cs

```c#
        public void ConfigureServices(IServiceCollection services)
        {
...
            services.AddCustomSecurity(this.Configuration);
...
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
...
            app.UseCors(SecurityMethods.DEFAULT_POLICY);  //   
...                     
```

## mettre cors au niveau d'un controller

- possible de mettre: [DisableCors()] aux actions que l'on ne veut pas appliquer le cors

```c#
    [EnableCors(SecurityMethods.DEFAULT_POLICY_2)]
    public class SelfiesController : ControllerBase
    {
```

## mettre cors au niveau d'une action d'un controller

```c#
        [HttpGet]
        [EnableCors(SecurityMethods.DEFAULT_POLICY_3)]
        public IActionResult GetAll([FromQuery] int wookieId = 0)
        {
```

## 

appsettings.json

```c#
  "Cors": {
    "Origin": "http://127.0.0.1:4200"
  },
```


```c#
            services.AddCors(options =>
            {
                options.AddPolicy(DEFAULT_POLICY, builder =>
                {
                    builder.WithOrigins(configuration["Cors:Origin"])
                           .AllowAnyHeader()
                           .AllowAnyMethod();
                });
                ...
```

# jwt

- IdentityDbContext

```c#
namespace Com.Core.Dotsafe.Infrastructure.Data
{
    public class DotsafesContext : IdentityDbContext, IUnitOfWork
    {
```

- création des tables users et roles...

```
dotnet ef migrations add identity
dotnet ef database update
```

Startup.cs

```c#
            app.UseAuthentication(); //
```

- installer package nuget: Microsoft.AspNetCore.Authentication.JwtBearer


appsettings.json

```c#
  "Jwt": {
    "Key": "maclefsecrete"
  }
```

SecurityMethods.cs

```c#
...
namespace Com.Core.Dotsafe.UI.ExtensionsMethods
{
        ...
        public static void AddCustomSecurity(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddCustomCors(configuration);
            services.AddCustomAuthentication(configuration);
        }

        public static void AddCustomAuthentication(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddJwtBearer(options =>
            {
                string maClef = configuration["Jwt:Key"];
                options.SaveToken = true;
                options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters()
                {
                    IssuerSigningKey = new SymmetricSecurityKey(System.Text.Encoding.UTF8.GetBytes(maClef)),
                    ValidateAudience = false,
                    ValidateIssuer = false,
                    ValidateActor = false,
                    ValidateLifetime = true
                };
            }); ;
        }
...        
```

- installer package nuget: Microsoft.AspNetCore.Identity.UI

Startup.cs

```c#
        public void ConfigureServices(IServiceCollection services)
        {
...

            services.AddDefaultIdentity<IdentityUser>(options =>
            {
                // règles   
                options.Password.RequiredLength = 8;
                options.SignIn.RequireConfirmedEmail = true;
                //
                //
            }).AddEntityFrameworkStores<DotsafesContext>();
```

- /controllers -> ajouter -> controlleur -> [.....Controller]


- sur le controller, ajouter le controle JWT avec : ```[Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]``` 

/controllers/AuthenticateController.cs

```c#
namespace Com.Core.Dotsafe.UI.Controllers
{
    [Route("api/v1/[controller]")]
    [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]    // (1)
    [ApiController]
    public class DotsafesController : ControllerBase
    {
```

- remarque :   (1) et (2)

Com.Core.Dotsafe.UI.ExtensionsMethods/SecurityMethods.cs

```c#
        public static void AddCustomAuthentication(this IServiceCollection services, IConfiguration configuration)
        {
            services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;    // (2)
```

# secret phrase 

- plutôt que mettre les données secret dans appSettings.json
- on le met dans les variables d'environnements

...UI -> gerer les données secrete de l'utilisateur

secrets.json

```json
{
  "Jwt": {
    "Key": "this is my custom Secret key for authentication"
  }
}
```

- mode developpement ?

...UI/properties/launchSettings.json 

```c#
...
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
...      
```

- remarque:
    - en prod, il faudra mettre les données secrete dans un endroit sécurisé (variable d'environnement)
    - pour le fonctionnement, en developpement, on le met dans secrets.json (donc valable uniquement en developpement)

## remplacer les fichiers json de configuration par des classes de configuration

- un fichier json est en fait une representation d'une classe :

..Infrastructure/Configurations/SecurityOption.cs

```c#
namespace Com.Core.Dotsafe.Infrastructure.Configurations
{
    public class SecurityOption
    {
        public string Key { get; set; }
    }
}
```

- utilisation :

```c#
namespace Com.Core.Dotsafe.UI.ExtensionsMethods
{
        ...
        public static void AddCustomAuthentication(this IServiceCollection services, IConfiguration configuration)
        {
            SecurityOption securityOption = new SecurityOption();
            configuration.GetSection("Jwt").Bind(securityOption);
            ...
            ...
            string maClef = securityOption.Key;
            ...
```

idem avec Cors:Origin

## remplacer les fichiers json de configuration par injection de dépendances des options


UI/ExtensionsMethods/OptionsMethods.cs

```c#
namespace Com.Core.Dotsafe.UI.ExtensionsMethods
{
    public static class OptionsMethods
    {
        public static void AddCustomOptions(this IServiceCollection services, IConfiguration configuration)
        {
            services.Configure<SecurityOption>(configuration.GetSection("Jwt"));
        }
    }
}
```

Startup.cs

```c#
            services.AddCustomOptions(this.Configuration);
```


```c#
    public class AuthenticateController : ControllerBase
    {
        #region Fields
        ...
        private readonly SecurityOption _options = null;
        #endregion

        #region Constructors
        public AuthenticateController(UserManager<IdentityUser> userManager, IConfiguration configuration, IOptions<SecurityOption> options)
        {
            ...
            this._options = options.Value;
        }
        #endregion
        ...
        ...
        var key = Encoding.UTF8.GetBytes(this._options.Key); 

```

# environnement

```
appSettings.json
    appsettings.Development.json   <==>   launchSettings.json-> "ASPNETCORE_ENVIRONMENT": "Development"
```

launchSettings.json

```c#
        "ASPNETCORE_ENVIRONMENT": "Development"
```

Startup.cs

```c#
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                ...
```

## ajouter un environnement STAGING

- par le fichier: launchSettings.json

```c#
  "profiles": {
...
    "IIS Express Staging": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Staging",
        "Jwt__Key": "this is my custom Secret key for authentication : IIS express staging"
      }
    },
    ...
```

- ou par l'éditeur visual studio 2022 :

```
UI -> propriété -> general -> profil de lancement de debogage -> IIS express -> variables d'environnement -> ASPNETCORE_ENVIRONMENT=Development
en:
UI -> propriété -> general -> profil de lancement de debogage -> IIS express -> variables d'environnement -> ASPNETCORE_ENVIRONMENT=Staging
```

- remarques:
    - en passant en mode staging, certaines configurations defini en developpement seront ignoirés :
        - secrets.json fonctionne qu'en developpement (donc jwt ne fonctionnera pas)
        - appSettings.json est en mode developpement : appsettings.Development.json (donc impacte la base de données qui est défini)

ajouter: appsettings.Staging.json

```json
  ...
  "ConnectionStrings": {
    "MariaDbConnectionString": "server=localhost;port=3306;database=dotsafedb_staging;user=root;password=root"
  }
```

- lancer environnement staging

éditeur visual studio 2022 -> en haut, bouton: "express IIS staging |>"




```c#

```


```c#

```


```c#

```


```c#

```


```c#

```


```c#

```


```c#

```


